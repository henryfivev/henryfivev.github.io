<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.15.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="简单地记录一下">
<meta property="og:type" content="website">
<meta property="og:title" content="望尘可及的秘密基地">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="望尘可及的秘密基地">
<meta property="og:description" content="简单地记录一下">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="henryfivev">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>望尘可及的秘密基地</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">望尘可及的秘密基地</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">henryfivev</p>
  <div class="site-description" itemprop="description">简单地记录一下</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">107</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">49</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/18/issta2024%E6%8A%95%E7%A8%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="henryfivev">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="望尘可及的秘密基地">
      <meta itemprop="description" content="简单地记录一下">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 望尘可及的秘密基地">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/12/18/issta2024%E6%8A%95%E7%A8%BF/" class="post-title-link" itemprop="url">issta2024投稿</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2023-12-18 15:17:45 / Modified: 15:21:40" itemprop="dateCreated datePublished" datetime="2023-12-18T15:17:45+08:00">2023-12-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Paper/" itemprop="url" rel="index"><span itemprop="name">Paper</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Paper/%E6%9D%82%E8%B0%88/" itemprop="url" rel="index"><span itemprop="name">杂谈</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <!-- 参考的两篇分别是泽钦师兄的SmartState和SmartDagger

## 一、SmartState

漏洞检测，SRV

### Abstract

平台。机制。出现的问题。挑战概述。模型简介。评估方法与结果。

### 1. introduction

111

### 2. background and motivation

2.1

智能合约，合约状态，以及状态回退机制

理解【smartstate处理的问题】所需的概念

2.2

机制中的漏洞

漏洞例子

先前研究及limitation

2.3

我们工作的优势，作用域111

### 暂略

3. overview

111

4. detail

111

### 5. evaluation

In this section, 

we first present our experimental setup and the two datasets for evaluation (the manual-labeled SRV dataset and the large-scale smart contracts dataset). 

Then, we show the evaluation results of SmartState in terms of false positives and false negatives over the manual-labeled SRV dataset. 

Lastly, we discuss the results of our large-scale analysis and identified new SRVs in the wild.

5.1

实验环境：ubuntu。。。

数据集：xblock

评价指标：precision、recall、f1

列举RQ1， RQ2， RQ3

5.2

对比实验

5.3

ASD和TSD的影响

消融实验

我们测试了smartstate中的独立组件。正如前文所述，asd和tsd是smartstate中重要的两个部分，保证了漏洞检测的soundness。例如，smartstate可以利用asd和tsd执行更多的漏洞追踪，和这些sota的方法相反。因此，asd和tsd的作用反应在recall得分。

描述一下，解释一下。

5.4

漏洞预警的表现

5.5

套话思路：



case study思路：

摆地址，介绍一下case情况
然后说有漏洞，漏洞在哪个函数，怎么导致的漏洞（漏洞具体原因）
因此该函数可以被黑客用来干嘛干嘛（体现漏洞的影响）
对此smartstate可以利用什么什么机制来检测漏洞（即模型检测漏洞的逻辑）

5.6

smartstate的limitation

### 6. related work

合约漏洞检测的先前工作：

现在很多程序分析工具支持智能合约漏洞检测。类似传统程序分析，这些工具分为静态分析和动态分析。静态分析工具有XXX，XXX，XXX。XXX，XXX，XXX是基于动态分析的工具。

然而这些工具都在SRV漏洞检测上的表现都差强人意，因为它们都没考虑细粒度的状态依赖。最近有两个工作是关注跨合约漏洞的，但它们基于源码，泛用性不行。

具体漏洞检测工作的介绍：

### 7. conclusion

这篇文章提出了smartstate，一个XXX框架。Smartstate可以分成两部分。首先，smartstate提取依赖关系并合成了一张细粒度状态依赖图。然后smartstate利用污点分析进行漏洞检测。我们在一个XXX的数据集和一个XXX的数据集上评估了smartstate。最后三句都是关于评估结果的。

## 二、SmartDagger

漏洞检测

### Abstract

研究的问题。现有方法的不足。不足导致的结果。模型简介。评估方法与结果。

### 1. introduction

111

### 2. background and motivation

2.1

智能合约，合约漏洞

2.2

跨合约漏洞

例子

2.3

先前工作及limitations

### 暂略

3. overview

111

4. detail

111

### 5. evaluation

In this section, 

we first introduce our implementation and evaluation setup. 

Then, we evaluate the effectiveness of SmartDagger by reporting its overall detection results, and compared SmartDagger with other state-of-the-art tools. 

We also evaluate the effectiveness and efficiency of SmartDagger’s individual components. 

Finally, we show how SmartDagger identifies cross-contract vulnerabilities in real world with two case studies.

5.1

实验环境

数据集

性能指标

列举RQ

5.2

对比实验：为了回答RQ1，我们测试了SmartDagger的precision和recall。同时也和其他优秀方法进行了对比。我们在同一个实验环境和数据集上获得的结果，并手动检查了结果。例如每个智能合约都有限定的运行时间。所有结果都是在ground-truth数据上测得的。注意我们不和基于源码的方法对比，因为他们的应用环境和我们不同。正如前文所述，源码分析将优于字节码分析因为源码包含更多的属性信息。

表2记录了smartdagger和其他工具的precision。如我们所见，和其他工具相比，smartdagger的precision更优。他们假阳是因为他们忽略了合约语义信息。表3记录了smartdagger和其他工具的recall。其他工具假阴是因为他们缺少巴拉巴拉。至此，我们说smartdagger表现好。

两段分别解释一下漏报和误报的情况。受限于反编译器。静态分析的局限性。

5.3

语义恢复和图构建的影响

正如前文所述，smartdagger的一个优势为它从反编译结果中恢复了合约属性信息，这是十分重要。我们通过检测重入漏洞来评估smartdagger和其他工具的表现。从图中可见，smartdagger的precision高多了。为搞清楚为什么precision高，我们人工检查了所有其他工具的假阳结果。我们发现其中一部分可以被恢复语义来避免。

另一个优势是smartdagger利用过程间分析构建了复杂的xCFG和xDFG图。这些图帮助smartdagger进行污点追踪，巴拉巴拉。构建xCFG和xDFG的有效性体现在recall得分上。由于sota缺少足够的过程间分析，随着深度加深，他们的recall下降严重。然而smartdagger依旧表现良好。我们人工检查了所有其他工具的假阴结果，分析表示大部分的假阴可以通过构建端到端的XXX分析来避免。分析了一个case

5.4

相较于其他工作的性能表现

5.5

case study

5.6

limitations

### 6. related work

合约漏洞检测的工作：

最近很多程序分析支持检测solidity漏洞。相同的，可以分成静态和动态工具。例如，XXX，XXX，XXX是基于静态分析的，它们这些工具怎么怎么样。其他工具，比如说XXX，XXX，是基于动态分析的。

然而这些工具都在跨合约分析上的表现都差强人意，因为它们都没考虑XXX。最近有两个工作XXX和XXX是关注跨合约漏洞的，但它们基于源码，泛用性不行。

程序分析：

语义恢复是一种重要的程序分析技术，用于在分析中推断所需的上下文信息。在传统语言中，语义恢复已被广泛应用，以实现XXX，XXX，XXX程序。在智能合约中包含更丰富的语义信息，比如巴拉巴拉，这些信息未充分利用于漏洞检测。

过程间分析对于定位漏洞代码十分重要。然而执行wpa会导致大量性能开销。在传统语言中，组合分析是解决wpa低效率的一个方法。它按需分析部分程序以提高效率，在传统程序中效果良好。smartdagger采用了这一思想，以提高效率。

### 7. conclusion

这篇文章，我们提出了SmartDagger，一个XXX框架。为了解决已有方法误报漏报的情况，smartdagger先恢复了合约属性信息。然后执行过程间分析。为了提高效率，实施了两种优化策略。两句话分别描述了一下两种策略。评估结果表示smartdagger是目前最好的。

## 三、PonziHunter

庞氏合约检测

### Abstract

近年来，区块链技术发展迅速，受到广泛关注。 然而，其去中心化和匿名性也吸引了许多犯罪活动。 其中，庞氏骗局这种经典的金融诈骗形式，也将其真面目隐藏在智能合约中，给区块链用户造成巨大损失。 

尽管已经提出了许多方法来检测庞氏合约，但这些方法未充分利用对数据流信息，无法准确提取庞氏逻辑，在泛用性和特征提取方面仍然存在局限性。 为了解决这个问题，我们对目前最大的智能合约区块链平台以太坊进行研究，提出了一种新颖的基于对比学习的智能庞氏骗局检测方法，名为PonziHunter。 

我们先将字节码反编译成中间表示，然后在中间表示上构建跨函数的控制流图并建立过程内和过程间的状态变量依赖，接着我们利用程序切片技术定位庞氏逻辑基本块，最后利用对比学习来进行庞氏检测。

真实世界数据的实验结果表明，PonziHunter明显优于以太坊庞氏骗局检测的最新技术。

### 1. introduction

111

### 2. background and motivation

理解我们motivation所需的相关概念

2.1

智能合约，合约异常检测，transferAPI

2.2

庞氏合约

例子

2.3

先前工作及limitations

我们工作的优势，like基于操作码，适用合约多

### 3. overview

概述：在本节中，我们首先介绍检测检测庞氏合约的挑战，以及 PonziHunter 中提出的解决方案。 然后，我们介绍一下PonziHunter的工作流程。

In this section, we first discuss the challenges encounted detecting Ponzi contracts and the solutions proposed within PonziHunter. Subsequently, we present an overview of the workflow of PonziHunter.

#### 3.1 Challenges and Solutions

##### 开头

开头：PonziHunter旨在在字节码层面进行庞氏合约检测，下面我们详细阐述PonziHunter面临的主要挑战以及相应的解决方案。

PonziHunter is designed to detecting Ponzi contracts at the bytecode level. In the following, We will now delve into a detailed exposition of the major challenges faced by PonziHunter and the respective solutions it applies.

##### C1: Extracting Ponzi Logic from Bytecodes

C1：在源码层面，我们可以很轻易地通过理解代码逻辑，观察变量名称等操作来提取代码语义信息，以此对合约进行庞氏检测。但正如前文所述，区块链上大多数智能合约不是开源。因此我们考虑从字节码层面进行庞氏语义提取。然而在字节码层面同样存在挑战，由于合约被编译成字节码，合约丢失了大量的语义信息，无法直观地提取代码语义。

At the source code level, we can easily extract semantic information about the code by understanding the code logic, observing variable names, and other operations as a way to perform Ponzi detection on the contract. However, as previously mentioned, the majority of smart contracts on the blockchain are not open-sourced. Therefore, we consider extracting Ponzi semantics from the bytecode level. However, at the bytecode level, since the contract is compiled into bytecode, the contract loses a lot of semantic information and it is hard to extract the code semantics intuitively.

C1solution：为解决这一挑战，我们考虑采用以下解决方案：将智能合约的字节码反编译为三地址码，这是一种中间语言表示（IR）。这种转换的主要优点是，与原始的底层字节码相比，三地址码提供了更清晰、更接近高级语言的代码形式。这种中间语言的结构和语义更加明确，便于进行分析。通过这种方式，我们可以更容易地识别和解析合约中的关键逻辑和潜在的庞氏特征。三地址码中的每个语句大致对应于源码中的一条简单指令，这使得从字节码中提取逻辑结构和意图变得更加可行。此外，使用中间语言还有助于应对不同的区块链平台和字节码格式，因为一旦将字节码转换为标准化的IR，相同的分析技术就可以跨多个平台使用。这种方法为从封闭源智能合约中提取庞氏逻辑提供了一种有效的技术手段。

To address this challenge, we consider the following solution: decompile the bytecode of smart contracts into triple-address code, which is an intermediate representation. The main advantage of this decompilation is that three-address code provides a clearer and closer form of code to a high-level language than the original underlying bytecode. The structure and semantics of this intermediate representation are much clearer and easier to analyze. In this way, we can more easily identify and parse the key logic and potential Ponzi features in a contract. Each statement in the three-address code roughly corresponds to a simple instruction in the source code, which makes it more feasible to extract the logical structure and intent from the bytecode. In addition, the use of an intermediate representation helps to cope with different blockchain platforms and bytecode formats, as the same analytics can be used across multiple platforms once the bytecode has been converted to the same type of IR. This approach provides an effective technical means for extracting Ponzi logic from closed-source smart contracts.

##### C2: Handling the Difficulties of Scarce Positive Samples

C2：在现有的公开数据集中，用于训练和测试庞氏合约检测模型的庞氏样本数量相对较少。与此同时，非诈骗性质的合约的数量占据了绝大多数。这种样本不平衡的现象对于基于机器学习的检测方法构成了显著的挑战，因为机器学习模型的效果很大程度上依赖于均衡和充分的训练数据。

In the currently available public datasets, the number of Ponzi samples used to train and test Ponzi contract detection models is relatively small. Meanwhile, the majority of contracts are non-fraudulent. This sample imbalance poses a significant challenge for machine learning-based detection methods, as the effectiveness of these models heavily relies on balanced and adequate training data.

C2solution：为了解决这个问题，我们提出了一种创新的解决方案：将三地址码建模为跨函数的控制流图，再应用图对比学习技术。控制流图是一种强大的工具，它能够将程序的逻辑结构以图形的形式呈现出来，使得程序的执行流程和分支决策更加直观。通过将三地址码转化为CFG，我们可以更清晰地捕捉到智能合约中的控制流结构和潜在的逻辑模式。在构建好控制流图的基础上，我们利用图对比学习技术来解决正样本稀少的问题。图对比学习是一种强大的机器学习方法，它通过比较和对照不同图形结构之间的差异来学习和识别模式。在我们的场景中，通过比较庞氏合约的控制流图与非诈骗合约的控制流图，我们可以有效地识别出那些与庞氏合约相关的独特模式和特征，即使在正样本非常稀少的情况下也是如此。这种方法不仅提高了庞氏合约的检测率，而且还有助于减少误报率，因为它能够更精确地区分庞氏合约和正常合约之间的微妙差别。

To solve this problem, we propose an innovative solution: modeling three-address code as a cross-functional control flow graph, and then applying graph contrastive learning techniques. A control flow graph is a powerful tool that presents the logical structure of a program in graphical form, making the execution flow and branching decisions more intuitive. By converting the three-address code into CFG, we can more clearly capture the control flow structure and potential logical patterns in smart contracts. On the basis of constructing an accurate control flow graph, we utilize graph contrastive learning techniques to address the scarcity of positive samples. Graph contrastive learning is a powerful machine learning method that learns and recognizes patterns by comparing and contrasting the differences between various graph structures. In our scenario, by comparing the control-flow graph of Ponzi contracts with that of non-fraudulent contracts, we can efficiently identify those unique patterns and features associated with Ponzi contracts, even in the context of very sparse positive samples. This method not only improves the detection rate of Ponzi contracts but also helps reduce the false positive rate by more accurately distinguishing the subtle differences between Ponzi and normal contracts.

##### C3: Locating the key Ponzi logic

面临的挑战：现有的庞氏合约逻辑复杂，如何定位关键庞氏逻辑代码？
解决办法：在控制流图上构建状态变量依赖边，在此基础上进行程序切片，将切片结果应用在对比学习策略中。

C3：在检测和防止基于智能合约的庞氏骗局时，我们面临着一个显著的挑战：这些合约往往具有复杂的逻辑结构，其中关键的庞氏逻辑代码可能隐藏在多层函数调用和复杂的交互逻辑中。这种复杂性不仅使得直接的代码审查变得困难，而且也为自动化的欺诈检测算法带来了挑战。关键问题在于，如何有效地定位那些实现庞氏逻辑的关键代码段，特别是在智能合约代码量大且结构复杂的情况下。

In detecting and preventing smart contract-based Ponzi schemes, we face a notable challenge: these contracts often have complex logical structures, where critical Ponzi logic code may be hidden in multiple layers of function calls and complex interaction logic. This complexity not only makes direct code review difficult, but also creates challenges for automated fraud detection algorithms. The key question is how to effectively locate those critical code segments that implement Ponzi logic, especially in the case of smart contracts with large and complex code.

C3solution：为了解决这个问题，我们提出了一种创新的方法：首先，在控制流图（CFG）上构建状态变量依赖边，再在新构建的图上进行程序切片，最后将切片结果应用在对比学习策略中。在控制流图上添加状态变量依赖边意味着我们不仅考虑了合约中的控制流，还考虑了状态变量之间的依赖关系。状态变量在智能合约中扮演着核心角色，它们存储了合约的关键信息，如用户余额、合约资产等。通过识别这些变量之间的依赖关系，我们可以更准确地捕捉到合约中的关键逻辑。接下来，基于构建的控制流图和状态变量依赖边，我们进行程序切片。程序切片是一种分析技术，它通过从程序中提取与特定操作或变量相关的所有语句来创建一个“切片”。这些切片有效地隔离了与特定功能或逻辑相关的代码部分，使得分析更加集中和高效。最后，我们将这些切片结果应用在对比学习策略中。在执行对比学习数据增强策略时，将切片结果作为特征，尽可能地保留体现庞氏逻辑的基本块。这种方法的优势在于它能够集中关注那些对于庞氏逻辑至关重要的代码段，从而提高了检测的精度和效率。

To solve this problem, we propose an innovative approach: first, constructing state-variable dependency edges on control flow graphs, then performing program slicing on the newly constructed graphs, and finally applying the slicing results in the contrastive learning strategy. Adding state-variable dependency edges to the control flow graph implies that we consider not only the contract's control flow but also the dependencies between state variables. State variables are crucial in smart contracts, storing key information such as user balances and contract assets. By identifying the dependencies between these variables, we can more accurately capture the key logic in the contract. Next, we conduct program slicing based on the control flow graph and state variable dependency edges. Program slicing is an analytical technique that isolates code segments relevant to a specific operation or variable, creating a 'slice' by extracting all related statements from the program. This method effectively isolates code parts pertinent to specific functions or logic, facilitating more focused and efficient analysis. Lastly, we apply these slices in the contrastive learning strategy. When performing the contrastive learning data augmentation strategy, we use the slicing results as additional features to preserve as much as possible the basic blocks that embody the Ponzi logic.The advantage of this method lies in its concentrated attention on code segments critical to Ponzi logic, thereby enhancing the detection's accuracy and efficiency.

#### 3.2 Framework of PonziHunter

111

### 4. detail

111

### 5. evaluation

#### 概述

这一节中我们先介绍了我们的实验环境和用于评估的数据集。然后我们在数据集上评估了PonziHunter的有效性，并将其与其他优秀方法进行比较。接着我们评估了PonziHunter各部分的有效性。除此之外我们还评估了参数对PonziHunter的影响。最后我们在两个具体例子上演示了PonziHunter是如何进行检测的。

In this section, we first introduce our experimental setup and the dataset utilized for evaluation. Subsequently, we assess the efficacy of PonziHunter on this dataset and compare it with other exemplary methods. Following this, we evaluate the effectiveness of the various components of PonziHunter. In addition, we also examine the impact of parameters on PonziHunter's performance. Finally, we demonstrate how PonziHunter conducts detection through two specific examples.

#### 5.1 setup

##### 实验环境

编程语言，行数，实验环境

PonziHunter is implemented in Python with around 1000 LOC. And all the experiments are conducted on a server running Ubuntu 20.04 with an Intel Core i9 CPU and 128 GB Memory.

##### 数据集

参考：我们研究中使用的数据集来自XBlock（https://xblock.pro/），这是一个在先前相关研究中广泛使用的区块链数据平台。 直接从 XBlock 获取的数据集共有 6,498 条合约记录，其中包括 314 条手动标记的庞氏合约。 然而，该数据集在我们实际使用之前经过了预处理。 我们删除了重复的合约，并消除了未能转换为控制流图的合约子集。 因此，我们研究中使用的数据集包含 6,371 份合同记录，其中包括 305 份庞氏合同。 此外，在数据增强之后，我们获得了这些智能合约的 295,521 个字节码变体。 为了进行综合评估，我们将智能合约集合随机分为三种方式，如表2所示。在庞氏骗局检测任务中，我们将庞氏骗局合约视为正样本，将正常合约视为负样本。 对于每次分割，所有训练集、验证集和测试集中都保持正样本和负样本的比例。 我们采用广泛使用的指标，包括召回率、精度和 F1

ours：我们研究中使用的数据集来自一个在先前相关研究中广泛使用的区块链数据平台XBlock（https://xblock.pro/）。 XBlock 的数据集共有 6,498 条合约记录，其中包括 314 条手动标记的庞氏合约。 该数据集在我们实际使用之前经过了预处理，我们删除了重复的合约，并消除了未能转换为控制流图的合约子集。 因此，我们研究中使用的数据集包含 6,371 份合同记录，其中包括 305 份庞氏合同。 为了进行综合评估，我们将智能合约集合随机分为三种方式，如表2所示。在庞氏骗局检测任务中，我们将庞氏骗局合约视为正样本，将正常合约视为负样本。 对于每次分割，所有训练集、验证集和测试集中都保持正样本和负样本的比例。 

In our study, the dataset was derived from XBlock (https://xblock.pro/), a blockchain data platform that has been extensively utilized in previous research. Initially comprising 6,498 contract records, which included 314 Ponzi contracts identified manually, the dataset underwent preprocessing before we employed it. This preprocessing involved the removal of duplicate contracts and the exclusion of contracts that were not amenable to conversion into control flow graphs. As a result, the dataset used in our research consisted of 6,371 contract records, with 305 of these being Ponzi contracts. For a comprehensive assessment, the smart contract set was randomly divided into three categories, as indicated in Table 2. Within the scope of detecting Ponzi schemes, contracts involved in Ponzi schemes were designated as positive samples, and normal contracts were categorized as negative samples. We ensured that the proportion of positive and negative samples remained constant across all the training, validation, and test sets for each division.

##### baseline

We select three categories of smart Ponzi contract detection methods as baseline methods, including opcode-based methods, transaction-based methods, and static program analysis method.

In opcode-based methods, we select Rideg-NC, SVM-NC, XGBoost-TF-IDF and MulCas. Ridge-NC is a linear classifier that incorporates L2 regularization to mitigate overfitting which is trained with the N-gram count feature of opcode sequences. SVM-NC is a machine learning model that finds optimal hyperplanes for effective binary classification which is also trained with the N-gram count feature of opcode sequences. XGBoost-TF-IDF is an ensemble gradient boosting algorithm that is trained with the TF-IDF feature of opcode sequences. MulCas is a Multi-view Cascade Ensemble method for detecting smart Ponzi schemes.

In transaction-based methods, we select XGBoost-Txn and LSTM-Txn. XGBoost-Txn is a method that utilizing hand-crafted transaction features to train the XGBoost classifier. LSTM-Txn is a recurrent neural network architecture designed to capture long-range dependencies in sequential data. We construct the transaction sequence features as the one we use in XGBoost-Txn.

In static program analysis methods, we select SADPonzi, which is a semantic-aware system for detecting smart Ponzi schemes using symbolic execution technology.

In Split1, the data is divided into 70% training set, 10% validation set and 20% test set while Split2 used 50% of the training set, 20% of the validation set and 30% of the test set. And Split3 was configured with 30% training set, 30% validation set and 40% test set.

##### 列举RQ

我们按照下面四个RQ来评估PonziHunter的表现。

RQ1. 和其它优秀的已有方法相比，PonziHunter在庞氏合约检测上的表现如何？
RQ2. PonziHunter中各部分是如何影响模型表现的？
RQ3. PonziHunter中参数对模型表现的影响？
RQ4. PonziHunter能否检测出现实世界中的庞氏合约？

We assess the performance of PonziHunter in accordance with the following four research questions (RQs).

RQ1. How does PonziHunter perform in detecting Ponzi contracts compared to other existing, well-regarded methods?

RQ2. How do the various components of PonziHunter impact the model's performance?

RQ3. What is the impact of parameters in PonziHunter on the model's performance?

RQ4. Is PonziHunter capable of detecting Ponzi contracts in real-world scenarios?

#### 5.2 Effectiveness of PonziHunter

##### 对比实验

参考aibc逻辑：基于opcode：XXX表现最好，XXX次优，所以推断更高级序列特征的有效性。基于交易：表现好，但仍不能和基于高级序列特征的模型相比。静态分析：f1不错但整体不行。出现这种差异可能是因为我们对sadponzi的限制。ContraPonzi：整体表现好其中f1尤其突出。和baseline对比，ContraPonzi利用了控制流信息和对比学习。

参考语义论文逻辑：表1记录了巴拉巴拉。我们的方法precision达到多少多少，比别人高多少，同recall和f1。我们注意到opcode的recall低，可能是因为他们学习的是统计特征，无法学到语义信息。因此这些方法对代码布局敏感而不是语义。不影响语义的代码布局改动将影响检测结果。

对比实验：为了回答RQ1，我们评估了PonziHunter和各个SOTA工具在三个数据集划分上的precision，recall和f1score。结果如表1所示，可以看到PonziHunter在f1score上较其他方法表现优异，同时整体表现也得分较高。

To answer RQ1, we evaluated the precision, recall, and f1score of PonziHunter and each SOTA tools on the three dataset splits.The results are shown in Table 1, where it can be seen that PonziHunter outperforms the other methods on the f1score, as well as scoring high on the overall performance.

对于基于操作码的方法来说，MulCas和XGBoost-TF-IDF的整体表现要优于基于Ngram的方法但低于PonziHunter。其中我们特别注意到了他们的recall得分和PonziHunter差距较大。这可能是因为这些基于字节码的方法只考虑了操作码频率分布特征，而忽略了控制流和数据流信息，因此产生较多误报，导致recall较低。

For the opcode-based methods, the overall performance of MulCas and XGBoost-TF-IDF is better than that of the Ngram-based methods but lower than that of PonziHunter. Specially, we notice a significant gap between their recall scores and that of PonziHunter. This may be due to the fact that these bytecode-based methods only consider the opcode frequency distribution feature and ignore the control flow and data flow information, thus generating more false positives and resulting in lower recall.

对于基于交易的方法来说，XGBoost-Txn的在三个数据集划分上的整体表现略优于只考虑了操作码频率分布特征的XGBoost-TF-IDF。但同时我们注意到随着训练集比例的减少，XGBoost-Txn的表现逐渐接近甚至略低于XGBoost-TF-IDF。我们认为这是因为随着交易数据减少，过少的交易数据导致模型出现更多的误报和漏报，从而获得更低的precision和recall。

For transaction-based methods, the overall performance of XGBoost-Txn across three dataset splits is marginally superior to XGBoost-TF-IDF, which only considers opcode frequency distribution features. However, we observe that as the proportion of the training set decreases, the performance of XGBoost-Txn gradually approaches, or even slightly inferior to, XGBoost-TF-IDF. "We believe this is because with the decrease in transaction data, the scarcity of transaction data results in the model generating more false positives and false negatives, thereby leading to lower precision and recall."

对于基于静态分析的方法来说，SADPonzi表现十分稳定，f1score持平MulCas但整体表现略低。这可能是因为SADPonzi执行速度较慢，大量例子执行时间过长而失败。也有可能是因为SADPonzi中的模式是手工定义的。

For static program analysis methods, SADPonzi performs very stably, with f1score equal to MulCas but overall performance slightly lower. This may be because SADPonzi executes slowly and a large number of examples take too long to execute and fail. It could also be because the patterns in SADPonzi are defined manually.

PonziHunter在f1得分上超过了其他所有SOTA工具且整体表现优秀。不过在我们看来，PonziHunter还存在不小的提升空间。经过我们调查发现，反编译器gigahorse在反编译结果中会多出一些用于返回状态变量值的函数。这些函数影响了状态变量依赖的准确性，导致PonziHunter出现了更多的误报。因此我们认为假如以后应用更加先进的反编译器将进一步减少误报。至于漏报，是因为我们仅在控制流图上构建了状态变量依赖，利用的控制流和数据流信息过少。因此我们认为假如能构建更多的依赖关系，利用更多达到控制流和数据流信息，能够进一步减少漏报，提高recall。

PonziHunter outperforms all other SOTA tools in terms of f1 score and overall performance. However, in our opinion, PonziHunter still has a lot of room for improvement. After our investigation, we found that the decompiler gigahorse has some extra functions in the decompiled result that are used to return state variable values. These functions affect the accuracy of state variable dependencies, leading to more false positives in PonziHunter. Therefore, we believe that if a more advanced decompiler is applied in the future, it will further reduce the false positives. As for the false negatives, it is because we only constructed the state variable dependencies on the control flow graph, which utilises too little control flow and data flow information. Therefore, we believe that if we can construct more dependencies and utilise more control flow and data flow information, we can further reduce false positives.

PonziHunter在f1得分上超过了其他所有SOTA工具且整体表现优秀。我们后续分析发现，我们的高recall得分得益于我们精确的控制流和数据流分析。精确的控制流和数据流分析提取出了较为齐全的合约语义，减少了漏报的情况。同时我们的高precision得分得益于我们的代码切片手段。我们定义的代码切片规则精准地提取出了合约中的庞氏语义，减少了误报的情况。

PonziHunter在f1得分上超过了其他所有SOTA工具且整体表现优秀。在一方面，PonziHunter可以更好地利用控制流和数据流信息，挖掘智能合约交易逻辑的关键基本块，并利用图挖掘技术学习代码结构特征，减少了误报的情况。在另一方面，PonziHunter采用了对比学习技术，其可以很好地处理标签稀缺的问题，并通过保留语义的数据扩充，增加样本的泛化能力，减少了漏报的情况。

##### 表格

略

#### 5.3 Effectiveness of XXX

状态依赖边的影响，程序切片

为了回答RQ2，我们评估了PonziHunter中代码切片部分的有效性。正如我们在章节4.3中提到，代码切片是PonziHunter中减少误报和漏报的重要手段。

#### 5.4 Effectiveness of 参数

除模型本身、消融实验外的、某方面的表现

We investigate the performance of ContraPonzi under different settings of temperature parameter τ in the task of Ethereum Ponzi contract detection, by varying τ from 0.05 to 100. As depicted in Figure 4, the optimal performance is achieved when τ is around 10, suggesting that this parameter setting can yield better classification performance

我们通过改变两个主要参数来评估PonziHunter的有效性：温度参数τ（范围在0.05到100之间）和学习率λ（调整范围在0.001到0.1之间）。如图4所示，当τ接近10和λ约为0.01时，性能达到峰值。

To answer RQ3, we evaluate the effectiveness of PonziHunter by altering two principal parameters: the temperature parameter τ, ranging from 0.05 to 100, and the learning rate λ, adjusted between 0.001 and 0.1. As illustrated in Figure 4, the peak performance is achieved with τ near 10 and λ approximately at 0.01.

#### 5.5 Case Study

##### 概述

概述：为了凸显PonziHunter相较于现有方法的有效性，我们具体分析了以下两个案例。这两个案例分别指出现有基于操作码的方法和现有基于交易数据的方法的不足，并说明PonziHunter是如何解决的。

概述v2：为说明PonziHunter有效性，我们提供了两个真实世界中的庞氏合约案例，这两个案例被 PonziHunter 检测到而未被其他模型检测到的例子。

To demonstrate the effectiveness of PonziHunter, we present two cases of real-world Ponzi contracts that were detected by PonziHunter but overlooked by other models.

##### case1

case1：在0xF835B307bc5348194ae01Ed729170c84217Ba688，这个是一个典型的链式庞氏合约。在XX函数中体现了具体的庞氏逻辑，该函数先判断投资金额是否符合要求，然后将新投资者加进投资者名单中，最后对一批老投资者发放奖金。然而，对于这个显然的庞氏合约，基于交易数据的检测方法却束手无策。出现这种情况是因为这种方法十分依赖于交易数据，在交易量少的合约表现不佳。但对于PonziHunter来说这不是困难，我们可以通过构建数据流依赖并对代码进行切片，来准确定位有关庞氏逻辑的代码。

At 0xF835B307bc5348194ae01Ed729170c84217Ba688, the smart contract represents a quintessential example of a chain-based Ponzi scheme. In the \textit{enter()}, the specific Ponzi logic is manifested. This function initially assesses whether the investment amount meets the set criteria, subsequently adds new investors to the list of investors, and finally distributes bonuses to a batch of existing investors. However, this apparent Ponzi scheme poses a challenge to detection methods based on transaction data. This limitation arises due to the heavy reliance of such methods on transaction data, which results in suboptimal performance for contracts with low transaction volumes. Nonetheless, this is not an obstacle for PonziHunter. We can accurately pinpoint the code related to Ponzi logic by constructing data flow dependencies and slicing the code.

case1v2：在0x177FA14AaFde5Ed17ab6C514FeC4715Adeb95BF0和0xfd2487cc0e5dce97f08be1bc8ef1dce8d5988b4d中，分别是两个代码类似的交接庞氏合约。它们先判断投资金额是否符合要求，然后将新投资者加进投资者名单中，最后对下一位老投资者发放奖金。然而，对于这两个庞氏合约，基于交易数据的检测方法却有着不一样的检测结果。出现这种情况是因为两个合约的交易量差距较大，其中一个合约只有6个交易，而另一个有474个交易。基于交易数据的检测方法十分依赖于交易数据，当合约交易量较少时表现不佳。但对于PonziHunter来说这不是困难，我们可以通过构建数据流依赖并对代码进行切片，来准确定位有关庞氏逻辑的代码。

At 0x177FA14AaFde5Ed17ab6C514FeC4715Adeb95BF0 and 0xfd2487cc0e5dce97f08be1bc8ef1dce8d5988b4d, the smart contracts are two relay Ponzi schemes with similar code structures. These contracts first verify if the investment amount meets the specified criteria, then add new investors to their list, and subsequently award bonuses to the next existing investor. However, for these two Ponzi contracts, methods based on transaction data yield different detection results. This discrepancy arises due to the significant difference in transaction volumes between the two contracts, where one has only six transactions, while the other boasts 474 transactions. Detection methods based on transaction data heavily rely on the volume of transactions and tend to perform poorly with contracts having fewer transactions. Nevertheless, this does not pose a challenge for PonziHunter. We can accurately locate the code related to Ponzi logic by constructing data flow dependencies and slicing the code.

##### case2

case2：在0x398bf07971475a020831d9c5e2ac24ff393b9862，这个智能合约是一个有推荐人机制的树形庞氏合约。主要庞氏逻辑体现在buyin()中，简单来说当有新投资者加入并指定一位推荐人时，合约将增加推荐人的奖金。对于基于操作码的方法来说，该合约并不容易进行检测，因为该合约的庞氏逻辑较其他庞氏合约复杂，玩法模式多样化。但这对PonziHunter影响不大。我们先构建状态变量依赖边，建立起状态变量之间的读写关系，再对CALL指令相关的基本块进行切片，以此来保留transferAPI相关的基本块，以定位庞氏逻辑。

At 0x398bf07971475a020831d9c5e2ac24ff393b9862, the smart contract is a tree-shaped Ponzi scheme with a referral mechanism. The primary Ponzi logic is embodied within \textit{buyin()}. In short, when a new investor joins and designates a referrer, the contract increments the bonus for the referrer. For methods based on opcode, this contract poses a challenge for detection due to its more complex Ponzi logic and diverse operational modes, compared to other Ponzi contracts. However, this is minimally impactful for PonziHunter. We start by constructing edges for state variable dependencies to establish read-write relationships between state variables. Then, we perform slicing on basic blocks related to the CALL instruction, thereby retaining the basic blocks associated with the transferAPI to locate the Ponzi logic.

case2v2：在0x398bf07971475a020831d9c5e2ac24ff393b9862，这个智能合约是一个机制较为复杂的树形庞氏合约，主要庞氏逻辑体现在buyin()中。该合约除了会对被指定为推荐人的投资者发放奖励外，当投资者再次投资时会根据距离上次投资的时间对投资者进行奖励。除此之外，合约还引入了轮数的机制。当当前合约余额不足以支付某个投资者奖金时，合约将把余额转账给合约所有者，并清空投资者名单，进入下一轮游戏。除了机制复杂外，合约代码也比较复杂，不仅存在多个函数间调用，还提供了多个信息查询接口。对于基于操作码的方法来说，该合约并不容易进行检测，因为该合约的庞氏逻辑较其他庞氏合约复杂。但这对PonziHunter影响不大。我们先构建状态变量依赖边，建立起状态变量之间的读写关系，再对CALL指令相关的基本块进行切片，以此来保留transferAPI相关的基本块，以定位庞氏逻辑。

At 0x398bf07971475a020831d9c5e2ac24ff393b9862, the smart contract represents a tree-shaped Ponzi scheme with a notably complex mechanism. The primary Ponzi logic is implemented in the \textit{buyin()}. In addition to rewarding investors designated as referrers, this contract also provides rewards to investors based on the time elapsed since their last investment when they reinvest. Furthermore, the contract incorporates a mechanism based on rounds. When the current contract balance is insufficient to pay a particular investor's bonus, the contract transfers the remaining balance to the contract owner, clears the list of investors, and commences a new round of the game. Beyond its intricate mechanism, the contract's code is also complex, featuring multiple inter-function calls as well as providing several interfaces for information queries. For methods based on opcode analysis, this contract presents a challenge for detection due to the intricacy of its Ponzi logic compared to other Ponzi contracts. However, this complexity has minimal impact on PonziHunter. We initially construct edges for state variable dependencies to establish read-write relationships between state variables. Subsequently, we perform slicing on basic blocks related to the CALL instruction, thereby retaining the basic blocks associated with the transferAPI, to pinpoint the Ponzi logic.

#### 5.6 limitations

我们工作的limitations

### 6. related work

#### 庞氏合约检测：

由于涉及金额庞大，出现了许多关于庞氏合约检测的工作。现有的庞氏合约检测主要分为基于交易数据分析和基于程序分析的方法。Hu et al. 将智能合约的交易序列数据划分为多个时间片，为每个时间片提取特征输入到LSTM中。Chen et al. 通过对旁氏骗局的行为进行分析和刻画，人工提取特征。但是，这些基于交易数据分析的方法无法实现在有受害者上当前的事前预警。由于以太坊上的智能合约大多没有源码，许多工作基于字节码分析进行旁氏骗局检测，例如MulCas，XGBoost-TF-IDF。但由于这些工作仅考虑了较为简单的操作码序列信息，没有考虑控制流、数据流等信息，在捕捉合约语义上存在不足。Cai et al. 提出了一种基于源码进行检测的方法，但泛用性不足，仅适用于开源合约。

Due to the involvement of large amounts of money, there has been considerable work on the detection of Ponzi schemes in contracts. Existing methods for detecting Ponzi contracts are primarily divided into those based on transaction data analysis and those based on program analysis. Hu et al. divided the transaction sequence data of smart contracts into multiple time slices, extracting features for each time slice to feed into an LSTM. Chen et al. manually extracted features by analyzing and characterizing the behavior of Ponzi schemes. However, these methods based on transaction data analysis fail to provide an early warning before the occurrence of victims. As most smart contracts on Ethereum do not have source code, many studies have resorted to bytecode analysis for Ponzi scheme detection, such as MulCas, XGBoost-TF-IDF. However, these studies only consider relatively simple opcode sequence information and neglect aspects like control flow and data flow, leading to inadequacies in capturing contract semantics. Cai et al. proposed a method based on source code analysis, but it lacks general applicability and is only suitable for open-source contracts.

#### 程序分析：

数据流分析是一种非常重要的程序分析技术，用于收集在程序执行过程中各种点上变量的信息。在传统语言中，数据流分析已被广泛应用，已实现编译优化、错误检测以及程序理解等等功能。在智能合约中包含更丰富的数据流信息，比如说状态变量，这些信息未充分利用于庞氏合约检测。

切片也是一种程序分析技术，用于定位关键代码。在传统语言中，一般基于系统依赖图来进行过程间切片，但系统依赖图十分复杂，这将导致大量性能开销。因此我们考虑在控制流图上构建变量依赖边，以降低图复杂度并提高效率。

#### 智能合约程序分析：

由于区块链上的智能合约与金融交易相关，且部署后不能更改，智能合约程序分析has gained a lot of interest[slither][Oyente][Securify][Sailfish][Ethainter][Mythril][sFuzz]。

目前的智能合约分析方法可归类为基于传统程序分析的方法和基于人工智能的方法。基于传统程序分析的方法包括数据流分析[def-use]、符号执行[KingJC]等静态分析方法[A survey of static program analysis techniques][]和动态测试方法[A systematic survey of program comprehension through dynamic analysis][]。SmartDagger反编译字节码并进行语义恢复后构建合约的控制流图，然后使用数据流分析技术来进行程序分析。SmartState分别从字节码和交易信息中提取出状态变量依赖和时序状态依赖，在此基础上构建出状态依赖图以进行程序分析。但是，传统程序分析方法依赖专家提取的规则。

而基于人工智能的方法由于不依赖预定的专家规则，近年来也开始被应用到区块链智能合约分析上。Zhuang et al. 首次将智能合约函数的syntactic and semantic structures信息建模为图，通过图神经网络学习进行漏洞检测。Su et al. 将人工智能技术与模糊测试技术相结合，用以生成易受攻击的交易序列以更好地检测智能合约的漏洞。在我们的工作中也考虑采用人工智能技术以实现以太坊旁氏合约的智能检测。

reference：

传统程序分析

King J C. Symbolic execution and program testing[J]. Communications of the ACM, 1976, 19(7): 385-394.

人工智能

Zhuang et al. [] （Smart Contract Vulnerability Detection Using Graph Neural Networks）

Su et al. [] （Effectively Generating Vulnerable Transaction Sequences in Smart Contracts with Reinforcement Learning-guided Fuzzing）

As smart contracts on the blockchain are related to financial transactions and cannot be altered after deployment, the analysis of smart contract programs has gained a lot of interest[slither] [Oyente] [Securify] [Sailfish] [Ethainter] [Mythril] [sFuzz]. Current methods for smart contract analysis can be categorized into those based on traditional program analysis and those based on artificial intelligence. Traditional program analysis methods include static analysis methods[A survey of static program analysis techniques][] such as data flow analysis[def-use] and symbolic execution[KingJC], as well as dynamic testing methods[A systematic survey of program comprehension through dynamic analysis][]. SmartDagger[smartdagger] decompiles bytecode and performs semantic recovery to construct a control flow graph of the contract, then uses data flow analysis techniques for program analysis. SmartState[smartstate] extracts state variable dependencies and temporal state dependencies from both bytecode and transaction information, building on this to construct a state dependency graph for program analysis. However, traditional program analysis methods rely on expert-extracted rules. On the other hand, AI-based methods, not reliant on predefined expert rules, have also begun to be applied to blockchain smart contract analysis in recent years. Zhuang et al. [Smart Contract Vulnerability Detection Using Graph Neural Networks][]first modeled the syntactic and semantic structures of smart contract functions as graphs, using graph neural networks to learn and perform vulnerability detection. Su et al. [Effectively Generating Vulnerable Transaction Sequences in Smart Contracts with Reinforcement Learning-guided Fuzzing][]combined AI technology with fuzz testing techniques to generate transactions sequences that are vulnerable to attacks, better detecting vulnerabilities in smart contracts. In our work, we also consider adopting AI technology to achieve intelligent detection of Ethereum Ponzi contracts.

### 7. conclusion

参考aibc：这篇文章中，我们提出了一个基于XXX进行庞氏检测的方法，XXX。这个方法主要解决了现有方法的XXX问题。我们先XXX，然后用XXX进行XXX。基于此，我们的方法除了利用XXX信息，还利用了XXX信息。同时，（机制中其他部分的作用）。评估表现。limitations。一句套话。 -->
<h2 id="四、issta投稿"><a href="#四、issta投稿" class="headerlink" title="四、issta投稿"></a>四、issta投稿</h2><h3 id="4-1-写作思路回顾"><a href="#4-1-写作思路回顾" class="headerlink" title="4.1 写作思路回顾"></a>4.1 写作思路回顾</h3><p>这次的投稿文章有7个章节，abstract，introduction，background and motivation，overview，detail，evaluation，related work和conclusion。</p>
<h4 id="内容较泛部分"><a href="#内容较泛部分" class="headerlink" title="内容较泛部分"></a>内容较泛部分</h4><p>可以一句话概括，然后用gpt进行扩写。</p>
<p>适用内容较泛部分，比如abstract第一段，introduction前几段，background和related work，甚至overview中解释solution的时候也可以小用一下doge。</p>
<h4 id="各部分内容"><a href="#各部分内容" class="headerlink" title="各部分内容"></a>各部分内容</h4><p>abstract简要介绍背景，motivation，提出的方法思路，表现。</p>
<p>introduction介绍背景，现有工作不足，然后引出我们的方法，介绍我们的方法思路，最后讲评估表现。</p>
<p>background and motivation要先介绍研究内容的基座，然后着重介绍我们设计方法的考量，用一个motivation example来说明我们发现了什么什么情况，基于这种情况我们这样设计模型。</p>
<p>overview先摆我们遇到的挑战以及我们的解决方案，尽可能涉及我们用的所有部分，然后分部分说方法的整体框架。</p>
<p>detail无他，就是详细介绍各个部分的细节。</p>
<p>evaluation先介绍setup，其中包括实验环境，数据集，性能指标，RQ，参数等等。然后对应RQ开始评估，一般有对比实验，消融实验，参数实验，摆几个case study，最后可以来个limitations。表现能解释解释，不能解释就直接描述结果。case不用过于详尽，但要体现我们选他的理由。</p>
<p>related work略。</p>
<p>conclusion就是abstract- background and motivation。</p>
<h3 id="4-2-标记规范"><a href="#4-2-标记规范" class="headerlink" title="4.2 标记规范"></a>4.2 标记规范</h3><p>自己瞎定的。</p>
<ol>
<li>用ffoo，XXX作为占位符</li>
<li>完成情况标记：1210todo表示1210做，doing表示正在做，todo？表示不一定做，done表示完成</li>
<li>原文注释规范：第X章开头：ffoo、第X节开头：ffoo</li>
</ol>
<h3 id="4-3-碎碎念"><a href="#4-3-碎碎念" class="headerlink" title="4.3 碎碎念"></a>4.3 碎碎念</h3><p>应该用钉钉的思维导图（okr那个），可以指派任务，完成后转移指派。</p>
<p>写论文真得开个gpt4，神中神，写废话和写代码利器。</p>
<p>chatgpt翻译 &lt; deepl翻译，gpt喜欢拽高级表述，很奇怪，会影响原文的重点，不过deepl有时候也是一坨。</p>
<p><a target="_blank" rel="noopener" href="https://www.tablesgenerator.com/#">画latex表格网址</a></p>
<p>excel画折线图，ppt画示意图，还可以用matlabplot画3d图和热力矩阵。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/03/%E9%A6%99%E6%B8%AF%E8%AD%A6%E5%8A%A1%E5%A4%84%E7%9D%A3%E5%AF%9F%E8%81%8C%E4%BD%8D%E5%BA%94%E8%81%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="henryfivev">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="望尘可及的秘密基地">
      <meta itemprop="description" content="简单地记录一下">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 望尘可及的秘密基地">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/03/%E9%A6%99%E6%B8%AF%E8%AD%A6%E5%8A%A1%E5%A4%84%E7%9D%A3%E5%AF%9F%E8%81%8C%E4%BD%8D%E5%BA%94%E8%81%98/" class="post-title-link" itemprop="url">香港警务处督察职位应聘</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-03 22:06:05" itemprop="dateCreated datePublished" datetime="2023-11-03T22:06:05+08:00">2023-11-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-11-04 10:14:36" itemprop="dateModified" datetime="2023-11-04T10:14:36+08:00">2023-11-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Think/" itemprop="url" rel="index"><span itemprop="name">Think</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>参加了一回港警招聘，记录一下相关信息。</p>
<p>香港警务处有在官网和公众号宣传招聘信息和宣传点信息，在广州设立了三天的宣传点，两天在SYSU，一天在暨大。</p>
<h2 id="宣传点"><a href="#宣传点" class="headerlink" title="宣传点"></a>宣传点</h2><p>先说宣传单上的信息吧。</p>
<p>督察要求本科且中英文一级，月薪5w+，警员仅要求DSE，月薪2.8w+。</p>
<p>督察先笔试，再两轮面试，警员无笔试仅有面试，都有体测，项目包括4x10、立定跳高、俯卧撑、800米。</p>
<p>在宣传点当场咨询了一个警员和督察，根据了解的情况来说，督察的面试每次一天，内容包括中英文自我介绍，小组讨论，时事分析，领导力展示等等，存在户外面试。心理测试不筛人。</p>
<p>PS. 确实存在中英夹杂的情况。</p>
<h2 id="笔试情况"><a href="#笔试情况" class="headerlink" title="笔试情况"></a>笔试情况</h2><p>下面说说考试的情况。</p>
<p>在公教楼使用了D402和D401两间教室，一间进行警员面试，一间进行笔试。宣传单上表示警员无笔试，但实际上考场有看见警员笔试的信息。</p>
<p>督察的话两篇作文，一篇中文一篇英文，各60分钟三百字，题目分别是《你希望居住在怎样的城市？》和《view on “money is not the only answer but it makes a difference”》，注意不接受简体字qaq。</p>
<p>警员的话，就我所看到的，好像全是选择题，有中文有英文（maybe，仅供参考）</p>
<p>考试氛围的话，十分的轻松，不用摘手表，不收手机，主监考十分友善hhhh。</p>
<p>不知道为什么他们对信息的涂改很重视，动不动就换一张。</p>
<h2 id="总体警员观感"><a href="#总体警员观感" class="headerlink" title="总体警员观感"></a>总体警员观感</h2><p>目测大概有7个人，两个督察，五个警员。</p>
<p>一个女督察一个男督察貌似没笑过，男督察说实话有点像姚sw，说话风格和精神面貌像，梳个大背头，贼壮，不怎么笑。感觉在宣传点热情介绍那个的男警员有点怕男督察，有点阿谀奉承。</p>
<p>在宣传点的另一个是女督察，也不笑，介绍情况倒是挺详细的。</p>
<p>在考场的是三个警员，一个负责面试，一个负责笔试，一个两边跑。噢男督察也是宣传点考场两边跑。</p>
<p>两边跑的警员也不爱笑，但不凶，我一开始拿红笔填信息她也没怪我，只是帮我换了一张，最后还鼓励我说努力hhhh。</p>
<p>考完之后和监考姐聊了一会，她还问我为什么要当警察，理工科明明有更好的出路，当警察压力大，还要受气hhhh。我说我不会说白话，她还说我会，只不过歪音hhhh。</p>
<h2 id="闲聊"><a href="#闲聊" class="headerlink" title="闲聊"></a>闲聊</h2><p>在外头填信息的时候和两个等待面试的同学聊，才知道督察面试对英语要求很高qaq，要英语自我介绍回答问题啥的。</p>
<p>他们还问我怎么敢没准备就报督导，还劝我换去警员hhhh。</p>
<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>从这次应聘还发现一些问题。</p>
<p>一个是做事态度出了问题，现在不会高中那样，一点点分解问题，尽可能去解决问题，现在是遇到问题，尝试一下，然后心里就拼命敲响退堂鼓了。</p>
<p>另一个是香港和内地工作氛围差异的问题，就从这次的观察来看，香港上下级之间的界限有点分明，工作氛围可能会压抑，可能存在职场霸凌？</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/30/%E5%BA%9E%E6%B0%8F%E5%90%88%E7%BA%A6%E6%95%B0%E6%8D%AE%E9%9B%86%E6%83%85%E5%86%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="henryfivev">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="望尘可及的秘密基地">
      <meta itemprop="description" content="简单地记录一下">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 望尘可及的秘密基地">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/10/30/%E5%BA%9E%E6%B0%8F%E5%90%88%E7%BA%A6%E6%95%B0%E6%8D%AE%E9%9B%86%E6%83%85%E5%86%B5/" class="post-title-link" itemprop="url">庞氏合约数据集情况</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2023-10-30 14:49:35 / Modified: 14:54:58" itemprop="dateCreated datePublished" datetime="2023-10-30T14:49:35+08:00">2023-10-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Blockchain/" itemprop="url" rel="index"><span itemprop="name">Blockchain</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Blockchain/%E5%BA%9E%E6%B0%8F%E5%90%88%E7%BA%A6/" itemprop="url" rel="index"><span itemprop="name">庞氏合约</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>数据集：<a target="_blank" rel="noopener" href="https://xblock.pro/#/dataset/25">https://xblock.pro/#/dataset/25</a></p>
<h2 id="传统庞氏合约"><a href="#传统庞氏合约" class="headerlink" title="传统庞氏合约"></a>传统庞氏合约</h2><p>目前将庞氏合约根据合约分配资金的模式分成4类：树形合约、链式合约、瀑布式合约和交接合约。</p>
<h3 id="树形合约"><a href="#树形合约" class="headerlink" title="树形合约"></a>树形合约</h3><p>用户之间的关系为树形结构。每当用户加入这个合约时，他必须将另一个用户指示为邀请者（父节点）。</p>
<p>新用户的钱在她的邀请者或邀请者的邀请者等等(即树形结构下的“祖先”)之间分配，逻辑是距离她越近邀请者获得的份额越大。</p>
<p>例子：Etheramid和DynamicPyramid</p>
<h3 id="链式合约"><a href="#链式合约" class="headerlink" title="链式合约"></a>链式合约</h3><p>用户之间的关系是线性的，每个节点都只有一个子节点。通常承诺一个常数因子（收益金额/投资金额），这个常数因子对所有用户都是相等的。合约按顺序一次性全额支付用户的收益。</p>
<p>所有新的投资都被收集起来，直到获得到期的金额。</p>
<p>例子：Doubler、dianaem和ZeroPonzi</p>
<h3 id="瀑布式合约"><a href="#瀑布式合约" class="headerlink" title="瀑布式合约"></a>瀑布式合约</h3><p>类似于链式合约，但分配逻辑不同。分发总是从链的头部开始，按顺序支付用户的收益，直到余额耗尽。</p>
<p>每次分钱会跳着分。</p>
<p>例子：TreasureChest和PiggyBank</p>
<h3 id="交接合约"><a href="#交接合约" class="headerlink" title="交接合约"></a>交接合约</h3><p>类似于链式合约，用户投资金额由合约决定，每次有新的用户加入，合约就会提高投资金额。合约将新用户的资金直接支付给前一个用户，前一个用户立即获得了利润。</p>
<p>例子：KingOfTheEtherThrone</p>
<h2 id="新发现"><a href="#新发现" class="headerlink" title="新发现"></a>新发现</h2><p>在数据集中发现有很多被标记为庞氏的合约是建立在自己实现的token上的，不一定符合ERC20标准。这类合约接收到新投资后，一般会增加老投资者的分红变量，而不是直接向老投资者转账。</p>
<h2 id="数据集不足"><a href="#数据集不足" class="headerlink" title="数据集不足"></a>数据集不足</h2><p>现在数据集有点旧，仅截止到2019年1月生成的区块7136486。</p>
<p>得更新一下数据集，从中找一个新模式的庞氏合约（或者我们自己想一个hhhh有没有可能整个跨链庞氏）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/30/Hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="henryfivev">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="望尘可及的秘密基地">
      <meta itemprop="description" content="简单地记录一下">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 望尘可及的秘密基地">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/10/30/Hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/" class="post-title-link" itemprop="url">Hexo插入图片</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2023-10-30 11:23:53 / Modified: 11:27:36" itemprop="dateCreated datePublished" datetime="2023-10-30T11:23:53+08:00">2023-10-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Blog/" itemprop="url" rel="index"><span itemprop="name">Blog</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Blog/Hexo/" itemprop="url" rel="index"><span itemprop="name">Hexo</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>亲测<a target="_blank" rel="noopener" href="https://blog.csdn.net/Miracle_ps/article/details/114791335中的第二个办法可行，这里mark一下。">https://blog.csdn.net/Miracle_ps/article/details/114791335中的第二个办法可行，这里mark一下。</a></p>
<p>方法一：</p>
<ol>
<li>找到Hexo下的_config.yml里的post_asset_folder，把这个选项从false改成true</li>
<li>在Hexo目录下打开Git Brsh，执行一个下载上传图片插件的命令npm install hexo-asset-image —save。</li>
<li>继续在Git Brsh下利用hexo n “xxxx”来生成md的文件（””里的内容填自己的文件名），这时就会在同级的目录下生成一个同名的文件夹。</li>
<li>在.md的文件中要插入图片时，先要把所要插入的图片放在生成的同名文件夹下。</li>
</ol>
<p>方法二：</p>
<p>在source路径下新建一个文件夹，然后用md语法正常插入即可。</p>
<p>如新建路径source/assets，则插入<code>![imgname](/assets/xxx.png)</code></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/30/Hexo%E7%9A%84Bug%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="henryfivev">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="望尘可及的秘密基地">
      <meta itemprop="description" content="简单地记录一下">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 望尘可及的秘密基地">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/10/30/Hexo%E7%9A%84Bug%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">Hexo的Bug记录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2023-10-30 10:50:43 / Modified: 11:26:10" itemprop="dateCreated datePublished" datetime="2023-10-30T10:50:43+08:00">2023-10-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Blog/" itemprop="url" rel="index"><span itemprop="name">Blog</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Blog/Hexo/" itemprop="url" rel="index"><span itemprop="name">Hexo</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Bug描述：hexo的categories和tags不对大小写进行区分，假如改变某个tag的大小写并同步到github上后将导致404。</p>
<p>解决方法：将.deploy_git中的categories或者tags路径删除，是不管用滴。要将.deploy_git/config中的ignorcase改为false才行。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/30/%E5%9F%BA%E4%BA%8E%E4%BA%A4%E6%98%93%E8%AF%AD%E4%B9%89%E8%AF%86%E5%88%AB%E7%9A%84%E5%BA%9E%E6%B0%8F%E5%90%88%E7%BA%A6%E6%A3%80%E6%B5%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="henryfivev">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="望尘可及的秘密基地">
      <meta itemprop="description" content="简单地记录一下">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 望尘可及的秘密基地">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/10/30/%E5%9F%BA%E4%BA%8E%E4%BA%A4%E6%98%93%E8%AF%AD%E4%B9%89%E8%AF%86%E5%88%AB%E7%9A%84%E5%BA%9E%E6%B0%8F%E5%90%88%E7%BA%A6%E6%A3%80%E6%B5%8B/" class="post-title-link" itemprop="url">基于交易语义识别的庞氏合约检测</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2023-10-30 00:32:26 / Modified: 11:26:10" itemprop="dateCreated datePublished" datetime="2023-10-30T00:32:26+08:00">2023-10-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Paper/" itemprop="url" rel="index"><span itemprop="name">Paper</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Paper/Blockchain/" itemprop="url" rel="index"><span itemprop="name">Blockchain</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一、论文信息"><a href="#一、论文信息" class="headerlink" title="一、论文信息"></a>一、论文信息</h2><p>题目：《Ponzi Scheme Detection in Smart Contract via Transaction Semantic Representation Learning》</p>
<p>级别：IEEE Transactions on Reliability，中科院二区，CCF-C类</p>
<p>作者院校：扬州大学</p>
<h2 id="二、论文动机"><a href="#二、论文动机" class="headerlink" title="二、论文动机"></a>二、论文动机</h2><p>现有方法的局限性：</p>
<ol>
<li>语义不足</li>
<li>庞氏关键语义获取</li>
<li>未充分利用特征</li>
</ol>
<p>提出一个基于学习交易语义的方法：用一种新的代码表示方法sTPG，将交易语义表示成一个图，然后利用gcn来学习交易模式。</p>
<p>设计方法的考量：</p>
<ol>
<li>为了处理复杂语义：cfg</li>
<li>为了处理无关代码：切片</li>
<li>状态变量的过程内数据依赖重要性</li>
</ol>
<h2 id="三、具体方法"><a href="#三、具体方法" class="headerlink" title="三、具体方法"></a>三、具体方法</h2><p>文中有给一个走完了全流程的例子，各部分的最后一段是对该例子的操作。</p>
<h3 id="训练阶段"><a href="#训练阶段" class="headerlink" title="训练阶段"></a>训练阶段</h3><p>简单说就是通过静态分析，程序切片和过程内状态变量依赖分析这三个步骤，从一个合约中获得一组sTPG，然后用这些sTPG作为特征进行训练。</p>
<h4 id="3-1-静态分析"><a href="#3-1-静态分析" class="headerlink" title="3.1 静态分析"></a>3.1 静态分析</h4><ol>
<li>先构建交易函数集</li>
<li>然后用slither对每个交易函数构建cfg</li>
<li>接着对每个cfg用forward dominance relation方法来获得控制依赖边，用变量def-use链来获得数据依赖边和数据流边</li>
<li>构建状态变量依赖边，从read到write</li>
</ol>
<p>至此对每个交易函数都有一个PDG图，图中有5种边，控制依赖边、数据依赖边、控制流边、数据流边和状态变量依赖边。</p>
<h4 id="3-2-程序切片"><a href="#3-2-程序切片" class="headerlink" title="3.2 程序切片"></a>3.2 程序切片</h4><p>对静态分析中获得的每个PDG应用以下两个切片标准：</p>
<ol>
<li>每个transfer API，后向切片</li>
<li>切片1中存在的全部状态变量，后向前向切片</li>
</ol>
<h4 id="3-3-过程内状态变量依赖分析"><a href="#3-3-过程内状态变量依赖分析" class="headerlink" title="3.3 过程内状态变量依赖分析"></a>3.3 过程内状态变量依赖分析</h4><p>在所有可调用的函数中，查找修改了(交易API依赖的状态变量)的语句，添加过程间状态变量依赖边，从read到write。</p>
<h4 id="3-4-模型训练"><a href="#3-4-模型训练" class="headerlink" title="3.4 模型训练"></a>3.4 模型训练</h4><p>初始化：</p>
<ul>
<li>节点嵌入初始化：用一个开源的基于AST的模型Infercode来获得向量</li>
<li>边嵌入初始化：先合并同方向边，接着将边编码成五维的onehot形式，每一维度分别表示控制流、数据流、数据依赖、控制依赖和状态变量依赖</li>
</ul>
<p>为了利用上边的信息，他们提出了一个relation-sensitive gcn：先用一个MLP计算边的隐藏特征，然后将节点特征和隐藏特征相拼接，用拼接后的特征进行图卷积（不太了解图卷积，这里没懂），最后用一个最大池化层和MLP进行分。</p>
<h3 id="检测阶段"><a href="#检测阶段" class="headerlink" title="检测阶段"></a>检测阶段</h3><p>类似训练阶段</p>
<h2 id="四、实验复现"><a href="#四、实验复现" class="headerlink" title="四、实验复现"></a>四、实验复现</h2><p>数据集是开源的，放在了<a target="_blank" rel="noopener" href="https://github.com/smartcontract-detect-yzu/PonziDataset，一部分是之前文章的开源数据集，一部分是从各个地方找合约然后人工打标签的，剩下是etherscan上标记为庞氏的。">https://github.com/smartcontract-detect-yzu/PonziDataset，一部分是之前文章的开源数据集，一部分是从各个地方找合约然后人工打标签的，剩下是etherscan上标记为庞氏的。</a></p>
<p>用slither进行静态分析，然后用Networkx构建sTPG，接着用Pytorch和PYG实现RS-GCN。</p>
<p>硬件信息和模型参数都有交代，见EXPERIMENT章节的Implementation段</p>
<h2 id="五、不足"><a href="#五、不足" class="headerlink" title="五、不足"></a>五、不足</h2><ol>
<li>仅针对solidity</li>
<li>识别出的交易语义源自一个交易函数——可扩展到跨函数交易语义挖掘</li>
<li>可尝试利用更多信息，比如AST中的信息</li>
<li>数据不平衡</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/30/%E9%9D%99%E6%80%81%E5%88%87%E7%89%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="henryfivev">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="望尘可及的秘密基地">
      <meta itemprop="description" content="简单地记录一下">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 望尘可及的秘密基地">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/10/30/%E9%9D%99%E6%80%81%E5%88%87%E7%89%87/" class="post-title-link" itemprop="url">静态切片</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-10-30 00:32:08" itemprop="dateCreated datePublished" datetime="2023-10-30T00:32:08+08:00">2023-10-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-11-02 15:38:48" itemprop="dateModified" datetime="2023-11-02T15:38:48+08:00">2023-11-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">程序分析</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/%E7%A8%8B%E5%BA%8F%E5%88%87%E7%89%87/" itemprop="url" rel="index"><span itemprop="name">程序切片</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>控制流图CFG、数据流图DFG、程序依赖图PDG、系统依赖图SDG</p>
<p>程序切片从可执行到不可执行</p>
<p>根据输入分类：静态切片，动态切片，有条件切片</p>
<p>程序切片应用之处</p>
<h2 id="二、图论基础"><a href="#二、图论基础" class="headerlink" title="二、图论基础"></a>二、图论基础</h2><h3 id="控制流图"><a href="#控制流图" class="headerlink" title="控制流图"></a>控制流图</h3><p>基本块：第一句进入，最后一句离开</p>
<p>控制流图以基本块为节点</p>
<h3 id="控制流和数据流"><a href="#控制流和数据流" class="headerlink" title="控制流和数据流"></a>控制流和数据流</h3><p>控制流分析就是去发现过程内or过程间的控制流</p>
<p>什么是过程？~函数</p>
<p>控制流图表示形式：</p>
<ol>
<li>AST</li>
<li>CFG</li>
<li>PDG中的控制依赖</li>
</ol>
<p>数据流描述了变量的值从定义点如何流到使用点</p>
<p>数据流边表示什么？~变量和变量之间的关系</p>
<p>可到达定义怎么计算？~求解数据流方程</p>
<h3 id="控制依赖和数据依赖"><a href="#控制依赖和数据依赖" class="headerlink" title="控制依赖和数据依赖"></a>控制依赖和数据依赖</h3><p>控制依赖：控制流引起的程序实体之间的关系</p>
<p>控制依赖定义：满足以下三个条件：</p>
<ol>
<li>n1n2之间存在可执行路径</li>
<li>对可到达路径上的其他点，n2都是它的后必经节点</li>
<li>n2不是n1的后必经节点</li>
</ol>
<p>条件语句内部的语句控制依赖于条件部分</p>
<p>数据依赖：由于数据定义和使用所形成的实体之间的关系</p>
<p>数据依赖定义：满足以下三个条件：</p>
<ol>
<li>n2定义了变量v</li>
<li>n1使用了变量v</li>
<li>n2n1存在可执行路径且变量v未重新定义</li>
</ol>
<h3 id="程序依赖图"><a href="#程序依赖图" class="headerlink" title="程序依赖图"></a>程序依赖图</h3><p>这里只是简单介绍</p>
<p>过程内依赖图：即过程依赖图PrDG，即控制依赖图+数据依赖图</p>
<p>过程间依赖图：即系统依赖图，各个过程依赖图+调用边+调用引起的依赖边</p>
<h2 id="三、静态程序分析"><a href="#三、静态程序分析" class="headerlink" title="三、静态程序分析"></a>三、静态程序分析</h2><h3 id="MarkWeiser程序切片"><a href="#MarkWeiser程序切片" class="headerlink" title="MarkWeiser程序切片"></a>MarkWeiser程序切片</h3><p>切片准则：<n, V>，n表示某个语句，V表示代码中变量的子集</p>
<p>其实就是在简化代码，希望留下切片准则相关的代码，求切片就是求图的可达性问题</p>
<p>切片结果可能不符合语法</p>
<p>切片优化：寻找最小切片问题是不可解的</p>
<p>不足：只能解决简单的程序，为了解决过程和过程调用的问题提出了过程内切片和过程间切片</p>
<h3 id="过程内切片"><a href="#过程内切片" class="headerlink" title="过程内切片"></a>过程内切片</h3><p>先在cfg上构建控制依赖图和数据依赖图，然后把两个图合并即可得到pdg</p>
<p>先构建程序依赖图pdg，再应用图可达性算法</p>
<p>前向后向区别：</p>
<ul>
<li>后向：是指以漏洞关注点为终点，能够到达该节点的所有路径上的所有节点</li>
<li>前向：是指从关注点节点出发，能够达到达到的所有路径上的节点</li>
</ul>
<h3 id="过程间切片"><a href="#过程间切片" class="headerlink" title="过程间切片"></a>过程间切片</h3><p>一样的逻辑，构建系统依赖图，然后应用图可达性算法</p>
<p>在过程依赖图上添加调用边、参数输入边和参数输出边形成系统依赖图（根据P50，好像有更多操作）</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《程序切片技术及其应用》</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/149894944">【南大软件分析】lecture7 笔记-Interprocedural Analysis</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/17/Cosmos%E6%8B%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="henryfivev">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="望尘可及的秘密基地">
      <meta itemprop="description" content="简单地记录一下">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 望尘可及的秘密基地">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/10/17/Cosmos%E6%8B%86%E8%A7%A3/" class="post-title-link" itemprop="url">Cosmos拆解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-10-17 17:49:12" itemprop="dateCreated datePublished" datetime="2023-10-17T17:49:12+08:00">2023-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-30 11:26:10" itemprop="dateModified" datetime="2023-10-30T11:26:10+08:00">2023-10-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Blockchain/" itemprop="url" rel="index"><span itemprop="name">Blockchain</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Blockchain/Cosmos/" itemprop="url" rel="index"><span itemprop="name">Cosmos</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Cosmos多链拆解"><a href="#Cosmos多链拆解" class="headerlink" title="Cosmos多链拆解"></a>Cosmos多链拆解</h2><p>区块链的发展：btc，eth，cosmos(多链)</p>
<h3 id="Tendermint共识机制"><a href="#Tendermint共识机制" class="headerlink" title="Tendermint共识机制"></a>Tendermint共识机制</h3><p>tendermint分为core和abci两个组件</p>
<h4 id="Tendermint-Core"><a href="#Tendermint-Core" class="headerlink" title="Tendermint Core"></a>Tendermint Core</h4><p>共识算法为优化后的POS</p>
<p>需要使用客户端以保证安全性和一致性</p>
<p>tendermint core作为共识引擎，网络层使用Gossip协议，共识层使用BFT+POS共识算法</p>
<p>验证者获得2/3的投票即添加新的区块</p>
<p>节点上限100个以保证性能</p>
<h4 id="ABCI接口"><a href="#ABCI接口" class="headerlink" title="ABCI接口"></a>ABCI接口</h4><ul>
<li>CheckTx：验证交易</li>
<li>DeliverTx：提交并更新状态</li>
<li>BeginBlock和EndBlock：查询状态</li>
</ul>
<h3 id="Cosmos-SDK"><a href="#Cosmos-SDK" class="headerlink" title="Cosmos SDK"></a>Cosmos SDK</h3><p>SDK内分成多个部分，开发者可以组合不同模块来构建DApp，也可以自行开发模块</p>
<p>支持WebAssembly</p>
<p>支持对象能力模型，将模块的运行逻辑保存在Keeper中。</p>
<h4 id="IBC协议"><a href="#IBC协议" class="headerlink" title="IBC协议"></a>IBC协议</h4><p>类似TCP/IP协议</p>
<p>建立握手连接：</p>
<ol>
<li>A链发起跨链到B链的OpenInit请求，等待Relayer接收到该请求。</li>
<li>Relayer收到OpenInit的请求之后，构造OpenTry的请求发送到B链上。</li>
<li>B链收到OpenTry请求之后，同意并确认之后生成OpenACK数据包，并由Relayer按照同样的方式发送给A链。</li>
<li>A链通过OpenACK数据包判断此次握手是否成功，成功则发送OpenConfirm并把包含信息的数据包返回B链，成功传输信息；否则握手失败。</li>
</ol>
<h3 id="Cosmos-vs-Polkadot"><a href="#Cosmos-vs-Polkadot" class="headerlink" title="Cosmos vs. Polkadot"></a>Cosmos vs. Polkadot</h3><ul>
<li>跨链协议：IBC和Parachain</li>
<li>共识机制：Tendermint和GRANDPA（ghost协议）</li>
<li>资产管理：账户模型和链上资产模型</li>
</ul>
<p>polkadot的中继链是平行链的唯一安全提供者，带来了一定的中心化。</p>
<h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><ol>
<li>gossip协议是什么？</li>
<li>ABCI接口没看明白？</li>
<li>Multistore机制是什么意思？</li>
<li>用SDK开发出的应用的运行逻辑？</li>
<li>cosmos和polkadot的资产管理分别是什么意思？</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/17/%E8%B7%A8%E9%93%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="henryfivev">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="望尘可及的秘密基地">
      <meta itemprop="description" content="简单地记录一下">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 望尘可及的秘密基地">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/10/17/%E8%B7%A8%E9%93%BE/" class="post-title-link" itemprop="url">跨链</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-10-17 11:07:15" itemprop="dateCreated datePublished" datetime="2023-10-17T11:07:15+08:00">2023-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-18 10:41:16" itemprop="dateModified" datetime="2023-10-18T10:41:16+08:00">2023-10-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Blockchain/" itemprop="url" rel="index"><span itemprop="name">Blockchain</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Blockchain/%E8%B7%A8%E9%93%BE/" itemprop="url" rel="index"><span itemprop="name">跨链</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="跨链是如何实现的"><a href="#跨链是如何实现的" class="headerlink" title="跨链是如何实现的"></a>跨链是如何实现的</h2><p>由于区块链可扩展性未解决</p>
<p>链之间的交互，数据、资产和功能的互通</p>
<h3 id="一、跨链通信"><a href="#一、跨链通信" class="headerlink" title="一、跨链通信"></a>一、跨链通信</h3><p>主要有两类跨链通信：</p>
<ol>
<li>最小化信任跨链通信：集群内部，rollups</li>
<li>可信任跨链通信：集群之间</li>
</ol>
<h4 id="常见可信任跨链通信协议"><a href="#常见可信任跨链通信协议" class="headerlink" title="常见可信任跨链通信协议"></a>常见可信任跨链通信协议</h4><h5 id="1-IBC"><a href="#1-IBC" class="headerlink" title="1. IBC"></a>1. IBC</h5><p>cosmos中的核心部分，为一种标准（链间标准ICS），由TAO层和Application层组成。</p>
<p>点对点连接</p>
<p>链之间不是直接通信，用专用通道发送信息，通道中包含一个轻客户端</p>
<h5 id="2-ZK"><a href="#2-ZK" class="headerlink" title="2. ZK"></a>2. ZK</h5><p>用zkp代替原数据</p>
<p>步骤：</p>
<ol>
<li>决定要传递的数据</li>
<li>获取证明数据存在EVM中的存储证明</li>
<li>由存储证明生成ZK证明，以默克尔树的形式</li>
<li>传递zkp</li>
<li>展开zkp</li>
<li>读取跨链信息</li>
</ol>
<h5 id="3-LayerZero"><a href="#3-LayerZero" class="headerlink" title="3. LayerZero"></a>3. LayerZero</h5><p>传输层协议，架构由端点、中继点和预言机组成</p>
<p>步骤：</p>
<ol>
<li>向communicator发送交易信息</li>
<li>communicator将交易信息以某种形式发送给validator</li>
<li>未完，有点复杂</li>
</ol>
<h5 id="4-axelar"><a href="#4-axelar" class="headerlink" title="4. axelar"></a>4. axelar</h5><p>验证者网络+网关智能合约+开发者工具</p>
<p>非点对点，链只需要接入一次即可跨多条链</p>
<h5 id="5-wormhole"><a href="#5-wormhole" class="headerlink" title="5. wormhole"></a>5. wormhole</h5><p>POA共识机制，核心合约+守护者网络。</p>
<p>守护者网络有19名守护者，负责交易验证</p>
<h3 id="二、跨链技术"><a href="#二、跨链技术" class="headerlink" title="二、跨链技术"></a>二、跨链技术</h3><h4 id="1-公证人机制"><a href="#1-公证人机制" class="headerlink" title="1. 公证人机制"></a>1. 公证人机制</h4><p>引入第三方来验证信息</p>
<p>有点像交易所</p>
<h4 id="2-哈希锁定"><a href="#2-哈希锁定" class="headerlink" title="2. 哈希锁定"></a>2. 哈希锁定</h4><p>借助哈希的单向性实现跨链交易</p>
<h4 id="3-侧链"><a href="#3-侧链" class="headerlink" title="3. 侧链"></a>3. 侧链</h4><p>two-way peg，在主链锁定货币后在侧链中释放等价货币</p>
<p>SPV模式：simplified payment verification，通过将交易发给本链的一个特殊地址，由此会自动创建一个SPV证明给侧链上并发起一个交易在侧链上解锁对应的资产。</p>
<h4 id="4-中继机制"><a href="#4-中继机制" class="headerlink" title="4. 中继机制"></a>4. 中继机制</h4><p>跨链信息通过中继链的验证者验证后发布到中继链上</p>
<h4 id="5-分布式私钥控制"><a href="#5-分布式私钥控制" class="headerlink" title="5. 分布式私钥控制"></a>5. 分布式私钥控制</h4><p>lock-in，lock-out，分片密钥</p>
<h3 id="三、跨链的未来展望"><a href="#三、跨链的未来展望" class="headerlink" title="三、跨链的未来展望"></a>三、跨链的未来展望</h3><ul>
<li>跨链桥</li>
<li>OmniChain NFT</li>
<li>layerzero的新应用</li>
<li>chainlink作为预言机</li>
<li>整合ICS标准</li>
</ul>
<h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><ol>
<li>跨链通信中的集群是什么意思？——同一生态，比如说polkadot中的平行链和中继链。</li>
<li>跨链通信协议和跨链技术的区别？——跨链通信协议是一种标准化的规则和协议，用于确保区块链之间的通信。跨链技术是一组具体的技术和方法，用于实际实现区块链之间的互操作性。跨链技术依赖跨链通信协议来建立通信，以实现跨链交互。这两者共同协助解决了区块链互操作性的挑战。</li>
<li>跨链桥是什么？——有点类似侧链</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/17/%E7%B2%BE%E9%80%9A%E4%BB%A5%E5%A4%AA%E5%9D%8A-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="henryfivev">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="望尘可及的秘密基地">
      <meta itemprop="description" content="简单地记录一下">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 望尘可及的秘密基地">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/10/17/%E7%B2%BE%E9%80%9A%E4%BB%A5%E5%A4%AA%E5%9D%8A-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/" class="post-title-link" itemprop="url">精通以太坊-智能合约安全</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2023-10-17 09:59:12 / Modified: 17:47:42" itemprop="dateCreated datePublished" datetime="2023-10-17T09:59:12+08:00">2023-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Blockchain/" itemprop="url" rel="index"><span itemprop="name">Blockchain</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Blockchain/%E7%B2%BE%E9%80%9A%E4%BB%A5%E5%A4%AA%E5%9D%8A/" itemprop="url" rel="index"><span itemprop="name">精通以太坊</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="九、智能合约安全"><a href="#九、智能合约安全" class="headerlink" title="九、智能合约安全"></a>九、智能合约安全</h2><h3 id="9-3-重入"><a href="#9-3-重入" class="headerlink" title="9.3 重入"></a>9.3 重入</h3><p>原理：调用外部fallback函数来进行转账，导致合约可重入</p>
<p>防范技术：</p>
<ol>
<li>用transfer()进行转账，虽然会带来额外gas</li>
<li>使用“检查-生效-交互”模式</li>
<li>使用互斥锁</li>
</ol>
<p>案例：DAO攻击</p>
<h3 id="9-4-算术溢出"><a href="#9-4-算术溢出" class="headerlink" title="9.4 算术溢出"></a>9.4 算术溢出</h3><p>原理：Solidity中整数存在上下限</p>
<p>防范技术：</p>
<ol>
<li>使用SafeMath库合约</li>
</ol>
<p>案例：PoWHC</p>
<h3 id="9-5-意外的以太币"><a href="#9-5-意外的以太币" class="headerlink" title="9.5 意外的以太币"></a>9.5 意外的以太币</h3><p>原理：强制发送以太币导致合约无法执行，self-destruct或预先发送都可以实现</p>
<p>防范技术：</p>
<ol>
<li>少用this.balance，使用状态变量保存余额</li>
</ol>
<h3 id="9-6-delegatecall"><a href="#9-6-delegatecall" class="headerlink" title="9.6 delegatecall"></a>9.6 delegatecall</h3><p>原理：delegatecall保持上下文，状态或存储变量（可以在独立的交易之间保持其数值的变量）会按照它们被引入合约的顺序放置在存储槽中，这时我们改变的变量可能不是我们期望改变的。</p>
<p>防范技术：</p>
<ol>
<li>使用library关键字可以保证库合约是无状态和不会自我销毁的</li>
</ol>
<p>案例：Parity多重签名钱包的第二次攻击</p>
<h3 id="9-7-默认的可见性"><a href="#9-7-默认的可见性" class="headerlink" title="9.7 默认的可见性"></a>9.7 默认的可见性</h3><p>原理：Solidity函数可见性默认为public，可能出现纰漏</p>
<p>防范技术：为每个函数都指定可见性</p>
<p>案例：Parity多重签名钱包的首次攻击</p>
<h3 id="9-8-无序错觉"><a href="#9-8-无序错觉" class="headerlink" title="9.8 无序错觉"></a>9.8 无序错觉</h3><p>原理：为了在以太坊中引入无序性（即随机性），使用哈希值、区块号等可被操控的区块变量作为随机值</p>
<p>防范技术：无序性必须来自区块链外部</p>
<p>案例：PRNG合约</p>
<h3 id="9-9-外部合约引用"><a href="#9-9-外部合约引用" class="headerlink" title="9.9 外部合约引用"></a>9.9 外部合约引用</h3><p>原理：可以故意将地址指向错误的合约，假如引用的合约不包含要调用的函数，将执行回退函数。如果用户可以修改合约引用的合约库，那么基本上他们就可以使其他用户在不知情的情况下运行任意代码。</p>
<p>防范技术：</p>
<ol>
<li>new一个要引用的合约</li>
<li>对外部合约进行硬编码</li>
</ol>
<p>一般建议将合约地址设置为public以方便用户检查引用的合约</p>
<p>案例：<a target="_blank" rel="noopener" href="https://www.reddit.com/r/ethdev/comments/7x5rwr/tricked_by_a_honeypot_contract_or_beaten_by/">可重入的蜜罐</a></p>
<h3 id="9-10-短地址攻击"><a href="#9-10-短地址攻击" class="headerlink" title="9.10 短地址攻击"></a>9.10 短地址攻击</h3><p>原理：当实际发送的数据长度小于标准编码长度时，EVM将在数据末尾补0，这种操作可能影响末尾参数</p>
<p>防范技术：对参数进行校验</p>
<h3 id="9-11-未检查的调用返回值"><a href="#9-11-未检查的调用返回值" class="headerlink" title="9.11 未检查的调用返回值"></a>9.11 未检查的调用返回值</h3><p>原理：send和call外部调用失败仅返回false，不revert</p>
<p>防范技术：</p>
<ol>
<li>检查返回值</li>
<li>使用withdraw模式</li>
</ol>
<h3 id="9-12-预先交易"><a href="#9-12-预先交易" class="headerlink" title="9.12 预先交易"></a>9.12 预先交易</h3><p>原理：gas高的优先被打包</p>
<p>防范技术：</p>
<ol>
<li>设置gas上限</li>
<li>使用commit-reveal模式</li>
<li>submarine sends</li>
</ol>
<p>案例：erc20的approve函数</p>
<h3 id="9-13-拒绝服务"><a href="#9-13-拒绝服务" class="headerlink" title="9.13 拒绝服务"></a>9.13 拒绝服务</h3><p>原理：各种原因使合约不可用，比如说事先向合约转账使合约无法通过某些限制条件</p>
<p>防范技术：各个情况方法不同</p>
<h3 id="9-14-区块时间戳操纵"><a href="#9-14-区块时间戳操纵" class="headerlink" title="9.14 区块时间戳操纵"></a>9.14 区块时间戳操纵</h3><p>原理：区块时间戳可被矿工指定。</p>
<p>防范技术：不应使用区块时间戳作为随机数。</p>
<p>案例：GovernMental</p>
<h3 id="9-15-小心使用构造函数"><a href="#9-15-小心使用构造函数" class="headerlink" title="9.15 小心使用构造函数"></a>9.15 小心使用构造函数</h3><p>原理：solidity0.4.22前，构造函数和合约同名；若合约名称和构造函数名称不同，构造函数将变成一个普通函数。</p>
<p>防范技术：使用constructor关键字。</p>
<p>案例：Rubixi</p>
<h3 id="9-16-未初始化的存储指针"><a href="#9-16-未初始化的存储指针" class="headerlink" title="9.16 未初始化的存储指针"></a>9.16 未初始化的存储指针</h3><p>原理：状态变量和复杂类型的局部变量都存储在storage中；状态变量按照顺序保存在storage中（存储槽），未初始化的局部变量可能指向已有的状态变量。</p>
<p>防范技术：用storage和memory关键字明确指定变量的存储位置。</p>
<p>案例：OpenAddressLottery</p>
<h3 id="9-17-浮点数和精度"><a href="#9-17-浮点数和精度" class="headerlink" title="9.17 浮点数和精度"></a>9.17 浮点数和精度</h3><p>原理：solidity的除法会舍去小于除数的所有精度。</p>
<p>防范技术：先执行加法和乘法，再执行减法和除法。</p>
<p>案例：Ethstick</p>
<h3 id="9-18-Tx-Origin验证"><a href="#9-18-Tx-Origin验证" class="headerlink" title="9.18 Tx.Origin验证"></a>9.18 Tx.Origin验证</h3><p>原理：全局变量tx.origin表示最初发起交易的账户地址；若使用tx.origin作为判定条件，合约易受到钓鱼攻击。</p>
<p>防范技术：少用tx.origin作为判定条件。</p>
<p>可用require(tx.origin == msg.sender)来拒绝外部合约调用。</p>
<h3 id="9-19-合约程序库"><a href="#9-19-合约程序库" class="headerlink" title="9.19 合约程序库"></a>9.19 合约程序库</h3><p>OpenZepplin包含丰富的库合约。</p>
<p>ZeppelinOS使开发者更简单地发布DApp。</p>
<h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><ol>
<li>谁可以调用合约的self-destruct</li>
<li>外部合约引用的防范技术没看懂</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">henryfivev</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","cdn":"//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
